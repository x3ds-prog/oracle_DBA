# Модуль 3: Внутреннее устройство базы данных

## Урок 1: Транзакции, `COMMIT` и `ROLLBACK`

Вы уже использовали `INSERT`, `UPDATE` и `ALTER TABLE`. Но как база данных гарантирует, что эти изменения не повредят данные, если что-то пойдет не так? Ответ — **транзакции**. Эта концепция абсолютно фундаментальна для работы с базами данных.

Транзакция — это одна или несколько команд SQL (`INSERT`, `UPDATE`, `DELETE`), которые выполняются как **единое целое**. Либо все команды в транзакции успешно завершаются, либо ни одна из них не оказывает никакого эффекта.

Это гарантия целостности данных, основанная на принципах **ACID**: Atomicity (Атомарность), Consistency (Согласованность), **Isolation (Изолированность)** и Durability (Долговечность). Сегодня мы на практике разберемся с Изолированностью и Долговечностью.

> **Для админа Linux: Аналогии**
>
> Представьте, что вы редактируете важный конфигурационный файл в `vim`.
>
> 1.  Вы открываете файл и вносите изменения. Эти изменения пока существуют только в вашем буфере `vim`. Ни один другой процесс в системе их не видит. Это **Изолированность**.
> 2.  Когда вы нажимаете `:wq`, вы **сохраняете** изменения на диск. Теперь они видны всем. Это аналог команды `COMMIT`.
> 3.  Если вы понимаете, что наделали ошибок, вы выходите без сохранения, набрав `:q!`. Все ваши изменения с момента открытия файла отменяются. Это аналог команды `ROLLBACK`.

### `COMMIT` и `ROLLBACK`: Сохранить или отменить

-   **`COMMIT`**: Делает все изменения, сделанные в текущей транзакции, постоянными и видимыми для всех остальных пользователей (сессий).
-   **`ROLLBACK`**: Откатывает (отменяет) все изменения, сделанные в текущей транзакции с момента ее начала (или с последнего `COMMIT`).

В Oracle **каждая сессия работает в своей транзакции**. Транзакция неявно начинается с первой DML-команды (`INSERT`, `UPDATE`, `DELETE`) и завершается явной командой `COMMIT` или `ROLLBACK`.

### Практический эксперимент: Изоляция транзакций

Этот эксперимент наглядно покажет, почему "потерялась" запись в ваших исходных заметках. Для него вам понадобится **два отдельных терминала** (или две отдельные вкладки/окна подключения в DBeaver). Назовем их **Сессия А** и **Сессия Б**.

**Шаг 1: Подготовка (в любой сессии)**
Очистим нашу таблицу для чистоты эксперимента.

```sql
-- Выполните в любой из сессий
DELETE FROM employees;
COMMIT;
```

**Шаг 2: Сессия А — Вносим изменение**
В окне **Сессии А** вставляем новую строку, но **не коммитим**.

```sql
-- Сессия А
INSERT INTO employees VALUES (100, 'Alice', 75000);
```

**Шаг 3: Проверяем видимость данных**
Теперь давайте посмотрим, что видят обе сессии.

```sql
-- Сессия А
SELECT * FROM employees;
```
**Результат в Сессии А:**
```
        ID NAME                                                   SALARY
---------- -------------------------------------------------- ----------
       100 Alice                                                 75000
```
Алиса на месте! Теперь выполните тот же запрос в **Сессии Б**:

```sql
-- Сессия Б
SELECT * FROM employees;
```
**Результат в Сессии Б:**
```
no rows selected
```
Пусто! Сессия Б ничего не знает об Алисе, потому что транзакция Сессии А еще не зафиксирована. Ее изменения изолированы.

**Шаг 4: Сессия А — Фиксируем транзакцию**
Теперь вернемся в окно **Сессии А** и сохраним изменения.

```sql
-- Сессия А
COMMIT;
```

**Шаг 5: Снова проверяем в Сессии Б**
Возвращаемся в **Сессию Б** и повторяем наш `SELECT` запрос.

```sql
-- Сессия Б
SELECT * FROM employees;
```
**Результат в Сессии Б:**
```
        ID NAME                                                   SALARY
---------- -------------------------------------------------- ----------
       100 Alice                                                 75000
```
Теперь Алису видят все. Команда `COMMIT` сделала изменения долговечными и видимыми для других.

### Выводы

-   Любые изменения данных (`INSERT`, `UPDATE`, `DELETE`) невидимы для других до тех пор, пока вы не выполните `COMMIT`.
-   Если вы закроете сессию, не выполнив `COMMIT`, все ваши изменения будут автоматически отменены (`ROLLBACK`). Именно поэтому пропадали ваши записи.
-   `COMMIT` — это ваш аналог `:wq` в `vim`. Не забывайте его нажимать, когда хотите сохранить результат своей работы.

### Что дальше?

Мы поняли, как Oracle обеспечивает целостность данных на логическом уровне. В следующем уроке мы опустимся еще ниже и посмотрим, как база данных физически адресует строки на диске, и познакомимся с аналогом `inode` в мире Oracle — `ROWID`.
