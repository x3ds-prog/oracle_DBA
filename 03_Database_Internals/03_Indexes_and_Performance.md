# Модуль 3: Внутреннее устройство базы данных

## Урок 3: Индексы и основы производительности

В предыдущем уроке мы узнали, что `ROWID` — это самый быстрый способ доступа к строке. Но как базе данных быстро найти `ROWID` для нужных нам данных, например, для сотрудника с `id = 100`, не перебирая всю таблицу?

Ответ: с помощью **индекса**.

### Что такое индекс?

Индекс в базе данных — это точная копия индекса (предметного указателя) в конце технической книги.

Представьте, что вам нужно найти информацию о "Транзакциях" в 1000-страничной книге по Oracle. Вы же не будете читать ее от корки до корки? Вы откроете указатель в конце, найдете слово "Транзакции", увидите рядом с ним номера страниц (например, 55, 102, 314) и сразу перейдете на них.

Индекс в Oracle работает точно так же:
-   **Ключ индекса** (например, значение `id` сотрудника) — это как слово в указателе книги.
-   **`ROWID`**, сохраненный рядом с ключом — это как номер страницы.

Индекс — это отдельная структура данных, которая хранит отсортированные значения одной или нескольких колонок и `ROWID`'ы, соответствующие этим значениям. Когда вы ищете по индексированной колонке, Oracle "смотрит" в индекс, мгновенно находит `ROWID` и считывает нужную строку с диска.

### `EXPLAIN PLAN`: Заглядываем в "мозг" Oracle

Прежде чем создать индекс, давайте научимся спрашивать у Oracle, как он **планирует** выполнять наш запрос. Для этого существует команда `EXPLAIN PLAN FOR ...`.

**Задача:** Посмотреть план выполнения для поиска сотрудника по `id`.

**Шаг 1: Получаем план**
Попросим Oracle проанализировать наш запрос и сохранить план в специальную таблицу.

```sql
EXPLAIN PLAN FOR
SELECT * FROM employees WHERE id = 100;
```

**Шаг 2: Отображаем план**
Теперь выведем сохраненный план в удобном виде с помощью системной функции.

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**Результат (до создания индекса):**
```
--------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |     1 |    34 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMPLOYEES |     1 |    34 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------
```
Самое важное здесь — строка с `Id = 1`, `Operation = TABLE ACCESS FULL`. Это означает **полное сканирование таблицы**. Oracle говорит нам: "Я собираюсь прочитать всю таблицу `employees` от начала до конца, чтобы найти то, что ты просишь". Для нашей таблицы из одной строки это не проблема, но для таблицы с миллионами записей это была бы катастрофа.

### `CREATE INDEX`: Ускоряем поиск

Теперь давайте создадим B-Tree индекс (самый распространенный тип) на колонку `id` нашей таблицы.

```sql
CREATE INDEX idx_employees_id ON employees(id);
```
-   `idx_employees_id`: Это имя индекса. Принято называть индексы по шаблону `idx_имятаблицы_имяколонки`.

### Снова смотрим план

База данных автоматически начинает использовать существующие индексы, если считает это эффективным. Давайте повторим наш эксперимент с `EXPLAIN PLAN`.

**Шаг 1: Получаем план (тот же запрос)**
```sql
EXPLAIN PLAN FOR
SELECT * FROM employees WHERE id = 100;
```

**Шаг 2: Отображаем план**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**Результат (после создания индекса):**
```
--------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name             | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                  |     1 |    34 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES        |     1 |    34 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | IDX_EMPLOYEES_ID |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------
```
Посмотрите, как все изменилось!
-   `TABLE ACCESS FULL` исчез.
-   Появилась операция `INDEX RANGE SCAN` по нашему индексу `IDX_EMPLOYEES_ID`. Oracle сначала заглянул в индекс.
-   Затем он выполнил `TABLE ACCESS BY INDEX ROWID`. Взяв `ROWID` из индекса, он точечно обратился к таблице и забрал только нужную строку.

Вы только что выполнили базовую операцию по оптимизации производительности (performance tuning).

### Выводы
-   Индексы критически важны для производительности запросов к большим таблицам.
-   Они ускоряют поиск, позволяя базе данных быстро находить `ROWID` нужных строк.
-   `EXPLAIN PLAN` — ваш главный инструмент для понимания того, как Oracle выполняет запросы. Умение читать его — ключевой навык DBA.

**Важно:** Не стоит индексировать все подряд. Индексы занимают место и замедляют операции записи (`INSERT`, `UPDATE`, `DELETE`), так как базе приходится обновлять не только таблицу, но и все связанные с ней индексы.

### Что дальше?
Вы получили базовое представление о внутреннем хранении, транзакциях и индексах. В последнем модуле мы разберем несколько практических задач, с которыми сталкивается каждый администратор: диагностика блокировок и анализ более сложных планов выполнения.
