# Модуль 2: Продвинутый SQL

## Урок 2: Группировка и агрегация данных

Часто от базы данных требуется не список отдельных записей, а итоговые, сагрегированные данные:
-   Какова общая сумма зарплат по каждому отделу?
-   Сколько сотрудников в каждом отделе?
-   Какая средняя зарплата в компании?

Для таких задач в SQL существуют **агрегатные функции** и оператор `GROUP BY`.

> **Для админа Linux: Аналогии**
>
> Если вы хотите посчитать количество уникальных IP-адресов в лог-файле, вы используете конвейер: `awk '{print $1}' access.log | sort | uniq -c | sort -nr`.
> Оператор `GROUP BY` в SQL — это как `sort | uniq -c` на стероидах. Он "схлопывает" множество строк в одну на основе значения в колонке и позволяет выполнить вычисления над каждой группой.

### Агрегатные функции

Это функции, которые принимают на вход набор значений (колонку) и возвращают одно-единственное значение. Основные из них:
-   `COUNT(column)`: считает количество не-NULL значений в колонке. `COUNT(*)` считает все строки.
-   `SUM(column)`: считает сумму всех значений.
-   `AVG(column)`: вычисляет среднее значение.
-   `MAX(column)`: находит максимальное значение.
-   `MIN(column)`: находит минимальное значение.

**Пример:** Посчитаем общее количество сотрудников и суммарный фонд оплаты труда (ФОТ) по всей компании.

```sql
SELECT
    COUNT(id) AS number_of_employees,
    SUM(salary) AS total_payroll
FROM employees;
```
*Обратите внимание: агрегатные функции игнорируют `NULL` значения. `SUM(salary)` не сломается из-за сотрудника без зарплаты.*

### `GROUP BY`: Разделяй и властвуй

А что если мы хотим посчитать ФОТ не для всей компании, а для **каждого отдела**?
Здесь в игру вступает `GROUP BY`.

**Задача:** Вывести названия отделов и сумму зарплат по каждому из них.

```sql
SELECT
    d.name AS department_name,
    SUM(e.salary) AS department_payroll
FROM
    employees e
JOIN
    departments d ON e.dept_id = d.id
GROUP BY
    d.name;
```

**Результат:**
```
DEPARTMENT_NAME                                    DEPARTMENT_PAYROLL
-------------------------------------------------- ------------------
Accounting                                                      60000
IT Support                                                        50000
```

**Что здесь произошло?**
1.  `FROM` и `JOIN` собрали данные из двух таблиц.
2.  `GROUP BY d.name` взял все строки и "сгруппировал" их по значению в колонке `d.name`. Все строки с 'IT Support' попали в одну группу, все с 'Accounting' — в другую. Сотрудник без отдела был отброшен на этапе `JOIN`.
3.  `SELECT` применил агрегатную функцию `SUM(e.salary)` к каждой группе отдельно.

### Золотое правило `GROUP BY`

Это правило — источник 90% ошибок на этом этапе. Запомните его:

> **Если в `SELECT` есть хотя бы одна агрегатная функция, то все остальные колонки, которые НЕ являются агрегатами, ДОЛЖНЫ быть перечислены в `GROUP BY`**.

Если вы попробуете выполнить такой запрос:
```sql
-- ОШИБОЧНЫЙ ЗАПРОС
SELECT
    d.name,
    e.name,  -- Эта колонка не агрегирована и не в GROUP BY
    SUM(e.salary)
FROM ...
GROUP BY d.name;
```
Oracle выдаст ошибку `ORA-00979: not a GROUP BY expression`.
Это логично: база не понимает, какое из имен сотрудников (`e.name`) она должна показать для отдела 'IT Support', если их там несколько.

### Потерянные данные: `LEFT JOIN` и `GROUP BY`

Посмотрите на результат нашего запроса по отделам. Куда пропал сотрудник Peter Jones, у которого нет отдела? Он был отфильтрован на этапе `INNER JOIN`.

Если мы хотим учесть его зарплату (даже если она `NULL`) в категории "Без отдела", мы должны использовать `LEFT JOIN`.

```sql
SELECT
    NVL(d.name, 'No Department') AS department_name,
    SUM(e.salary) AS department_payroll,
    COUNT(e.id) AS number_of_employees
FROM
    employees e
LEFT JOIN
    departments d ON e.dept_id = d.id
GROUP BY
    d.name; -- Группируем по "сырому" названию, NVL отработает при выводе
```
**Результат:**
```
DEPARTMENT_NAME                                    DEPARTMENT_PAYROLL NUMBER_OF_EMPLOYEES
-------------------------------------------------- ------------------ -------------------
No Department                                                                           1
Accounting                                                      60000                   1
IT Support                                                        50000                   1
```
Теперь наш отчет полон. Мы видим, что есть один сотрудник без отдела, и его вклад в ФОТ равен `NULL` (т.к. `SUM(NULL)` есть `NULL`). `COUNT(e.id)` при этом честно его посчитал, так как его `id` не `NULL`.

### Что дальше?

Мы научились агрегировать данные. Но что если нам нужно отфильтровать результат уже **после** агрегации? Например, показать только те отделы, где ФОТ больше 55000. `WHERE` здесь не поможет, и в следующем уроке мы узнаем, почему, и познакомимся с оператором `HAVING`.
