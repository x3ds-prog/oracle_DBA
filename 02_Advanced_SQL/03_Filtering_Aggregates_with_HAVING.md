# Модуль 2: Продвинутый SQL

## Урок 3: Фильтрация групп с помощью `HAVING`

Мы научились группировать данные и считать по ним итоги. Теперь рассмотрим следующую типичную задачу: "Покажите мне только те отделы, где фонд оплаты труда (ФОТ) превышает 55 000".

### `WHERE` vs `HAVING`: В чем разница?

Первый инстинкт — использовать `WHERE`, ведь мы привыкли к нему для фильтрации.

```sql
-- ОШИБОЧНЫЙ ЗАПРОС
SELECT
    d.name AS department_name,
    SUM(e.salary) AS department_payroll
FROM
    employees e
JOIN
    departments d ON e.dept_id = d.id
WHERE
    SUM(e.salary) > 55000 -- Так не работает!
GROUP BY
    d.name;
```

Этот запрос упадет с ошибкой `ORA-01137: invalid aggregate function`.

Чтобы понять, почему, давайте снова вспомним **логический порядок выполнения** SQL запроса:

1.  `FROM` / `JOIN`: Сбор данных.
2.  **`WHERE`**: Фильтрация **отдельных строк**.
3.  **`GROUP BY`**: Группировка отфильтрованных строк.
4.  **Агрегатные функции**: Вычисление `SUM()`, `COUNT()` и т.д. для каждой группы.
5.  **`HAVING`**: Фильтрация **целых групп** по результатам агрегатных функций.
6.  `SELECT`: Формирование финального вывода.
7.  `ORDER BY`: Сортировка финального вывода.

Ключевой момент: `WHERE` применяется **до** группировки и вычисления агрегатов. На этом этапе `SUM(e.salary)` еще просто не существует, поэтому его нельзя использовать для фильтрации.

Для фильтрации по результатам агрегации в SQL есть специальный оператор — `HAVING`.

### `HAVING`: `WHERE` для групп

Оператор `HAVING` по синтаксису похож на `WHERE`, но применяется **после** `GROUP BY` и работает уже с агрегированными результатами.

Давайте исправим наш запрос:

```sql
SELECT
    d.name AS department_name,
    SUM(e.salary) AS department_payroll
FROM
    employees e
JOIN
    departments d ON e.dept_id = d.id
GROUP BY
    d.name
HAVING
    SUM(e.salary) > 55000;
```

**Результат:**
```
DEPARTMENT_NAME                                    DEPARTMENT_PAYROLL
-------------------------------------------------- ------------------
Accounting                                                      60000
```
Этот запрос работает идеально. База данных сначала сгруппировала всех сотрудников по отделам, посчитала ФОТ для каждого, а затем оператор `HAVING` отбросил те группы (отделы), где сумма оказалась меньше или равна 55000.

### `WHERE` и `HAVING` в одном запросе

`WHERE` и `HAVING` не взаимозаменяемы, они выполняют разные задачи. Их можно и нужно использовать вместе для написания эффективных запросов.

-   **`WHERE`** отфильтровывает индивидуальные строки, которые не нужно включать в расчеты.
-   **`HAVING`** отфильтровывает группы уже после того, как расчеты по ним выполнены.

**Золотое правило производительности:** **Фильтруй как можно раньше.**
Всегда используйте `WHERE` для фильтрации по обычным колонкам. Это уменьшает количество строк, которые пойдут на более "дорогие" операции группировки и агрегации.

**Пример:** "Посчитать ФОТ по отделам, но учитывать только сотрудников с зарплатой больше 40000. Из итогового списка показать только те отделы, чей ФОТ превышает 55000".

```sql
SELECT
    d.name AS department_name,
    SUM(e.salary) AS department_payroll
FROM
    employees e
JOIN
    departments d ON e.dept_id = d.id
WHERE
    e.salary > 40000 -- Шаг 1: Убираем "дешевых" сотрудников ДО группировки
GROUP BY
    d.name
HAVING
    SUM(e.salary) > 55000; -- Шаг 2: Убираем "бедные" отделы ПОСЛЕ группировки
```
**Результат:**
```
DEPARTMENT_NAME                                    DEPARTMENT_PAYROLL
-------------------------------------------------- ------------------
Accounting                                                      60000
```
В данном случае, John Doe (`salary = 50000`) не прошел бы фильтр `WHERE salary > 40000`, и отдел 'IT Support' не попал бы в `HAVING`. Но логика запроса верна.

### Итоги Модуля 2

Вы освоили мощные инструменты для анализа данных:
-   Научились связывать таблицы с помощью `INNER JOIN` и `LEFT JOIN`.
-   Поняли, как важно не терять данные и как `NVL` помогает приводить отчеты в порядок.
-   Освоили агрегатные функции и группировку с `GROUP BY`.
-   Поняли ключевую разницу между `WHERE` и `HAVING` для фильтрации данных до и после агрегации.

В следующем модуле мы заглянем "под капот" базы данных и разберем темы, особенно близкие системным администраторам: как Oracle хранит данные, что такое транзакции и как работают индексы.
