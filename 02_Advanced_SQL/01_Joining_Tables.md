# Модуль 2: Продвинутый SQL

## Урок 1: Объединение таблиц (JOIN)

До сих пор мы работали с одной плоской таблицей `employees`. Но в реальном мире данные редко хранятся так просто. Они **нормализованы** — разделены на несколько взаимосвязанных таблиц, чтобы избежать дублирования и повысить целостность.

Например, вместо того чтобы хранить название отдела "IT Support" в каждой строке с сотрудником этого отдела, мы выносим отделы в отдельную таблицу, а в таблице сотрудников храним лишь идентификатор (ID) отдела.

Это — сердце реляционных баз данных. А `JOIN` — это операция, которая позволяет "собирать" данные из этих связанных таблиц в единый отчет.

### Подготовка: Создаем вторую таблицу

Давайте создадим таблицу для отделов и свяжем ее с нашими сотрудниками.

**1. Создаем таблицу `departments`:**

```sql
CREATE TABLE departments (
    id NUMBER,
    name VARCHAR2(50)
);
```

**2. Вставляем в нее данные:**

```sql
INSERT INTO departments VALUES (10, 'IT Support');
INSERT INTO departments VALUES (20, 'Accounting');
```

**3. Модифицируем таблицу `employees`, чтобы она могла ссылаться на отделы.**
Мы добавим в нее колонку `dept_id` с помощью `ALTER TABLE`:

```sql
ALTER TABLE employees ADD dept_id NUMBER;
```

**4. "Раздаем" сотрудникам отделы с помощью `UPDATE`:**

```sql
-- John Doe будет в IT Support
UPDATE employees SET dept_id = 10 WHERE id = 1;

-- Jane Smith будет в Accounting
UPDATE employees SET dept_id = 20 WHERE id = 2;

-- Peter Jones'у намеренно укажем несуществующий отдел.
-- Это нужно для демонстрации разницы в JOIN'ах.
UPDATE employees SET dept_id = 99 WHERE id = 3;

-- Не забываем зафиксировать все наши изменения!
COMMIT;
```

Теперь наши данные готовы к объединению.

### `INNER JOIN`: Поиск пересечений

`INNER JOIN` (или просто `JOIN`) — это самый распространенный тип объединения. Он возвращает только те строки, для которых нашлось **точное совпадение** в обеих таблицах. Это как пересечение множеств.

**Задача:** Вывести имена сотрудников и названия их отделов.

```sql
SELECT
    e.name AS employee_name,
    d.name AS department_name
FROM
    employees e
JOIN
    departments d ON e.dept_id = d.id;
```
*Обратите внимание на псевдонимы `e` и `d` — они делают код короче и читабельнее.*

**Результат:**
```
EMPLOYEE_NAME                                      DEPARTMENT_NAME
-------------------------------------------------- --------------------------------------------------
John Doe                                           IT Support
Jane Smith                                         Accounting
```
**Куда пропал Peter Jones?** У него `dept_id = 99`, а в таблице `departments` нет отдела с таким `id`. `INNER JOIN` не нашел совпадения и отбросил эту строку.

> **Для админа Linux: Аналогии**
>
> `INNER JOIN` очень похож на работу утилиты `join` в командной строке, которая по умолчанию выводит только те строки, у которых совпадает ключ в обоих файлах.

### `LEFT JOIN`: Как никого не потерять

Что если нам нужно вывести **всех** сотрудников, независимо от того, нашелся для них отдел или нет? Например, для отчета о "бесхозных" сотрудниках.

Для этого существует `LEFT JOIN` (левое внешнее соединение). Он говорит базе: _"Обязательно верни все строки из **левой** таблицы (та, что указана после `FROM`), и попытайся найти для них пару в **правой** таблице. Если пара не найдена — просто подставь `NULL`"_.

```sql
SELECT
    e.name AS employee_name,
    d.name AS department_name
FROM
    employees e
LEFT JOIN
    departments d ON e.dept_id = d.id;
```
**Результат:**
```
EMPLOYEE_NAME                                      DEPARTMENT_NAME
-------------------------------------------------- --------------------------------------------------
John Doe                                           IT Support
Jane Smith                                         Accounting
Peter Jones
```
Peter Jones вернулся! Но в колонке `department_name` у него `(null)`, потому что совпадения не нашлось.

### Бонусный трюк: Функция `NVL`

Пустота в отчетах выглядит некрасиво. Боссы и менеджеры любят понятные заглушки вроде "N/A" или "Без отдела".

В Oracle для замены `NULL` на другое значение есть удобная функция `NVL(value, replacement_if_null)`.

> **Для админа Linux: Аналогии**
>
> `NVL` — это полный аналог конструкции `${VARIABLE:-default_value}` в `bash`.

Давайте приведем наш отчет в идеальный вид:

```sql
SELECT
    e.name AS employee_name,
    NVL(d.name, 'No Department') AS department_name
FROM
    employees e
LEFT JOIN
    departments d ON e.dept_id = d.id;
```
**Результат:**
```
EMPLOYEE_NAME                                      DEPARTMENT_NAME
-------------------------------------------------- --------------------------------------------------
John Doe                                           IT Support
Jane Smith                                         Accounting
Peter Jones                                        No Department
```
Теперь отчет полон и понятен.

### Что дальше?

Вы освоили самую важную концепцию в реляционных базах данных. В следующем уроке мы научимся агрегировать данные: считать суммы, средние, количества и группировать их по категориям.
