# Модуль 1: Основы SQL

## Урок 2: Порядок выполнения SQL запроса и псевдонимы

В предыдущем уроке мы научились извлекать данные. Теперь давайте разберем, как их фильтровать, и столкнемся с первой неочевидной особенностью SQL — логическим порядком выполнения запроса. Это знание критически важно и объясняет 90% "странных" ошибок у новичков.

### Фильтрация данных: `WHERE`

Ключевое слово `WHERE` используется для фильтрации строк. В него вы передаете условие, и `SELECT` вернет только те строки, для которых это условие истинно.

Давайте найдем сотрудника с `id = 1`:

```sql
SELECT * FROM employees WHERE id = 1;
```
**Результат:**
```
        ID NAME                                                   SALARY
---------- -------------------------------------------------- ----------
         1 John Doe                                                50000
```
Это похоже на `grep` в Linux, который отбирает строки по шаблону.

### Ловушка: Порядок выполнения и псевдонимы

Давайте поставим себе задачу: посчитать годовую зарплату (`salary * 12`) и вывести только тех сотрудников, у кого она больше 650000.

Интуитивно, как программист, вы бы написали так:

```sql
-- Пытаемся выполнить ошибочный запрос
SELECT
    id,
    name,
    salary * 12 AS annual_salary
FROM
    employees
WHERE
    annual_salary > 650000; -- ОШИБКА!
```
*`AS` - это ключевое слово для создания псевдонима (alias) для колонки.*

Этот запрос упадет с ошибкой `ORA-00904: "ANNUAL_SALARY": invalid identifier`. Почему? Ведь колонка `annual_salary` объявлена прямо в `SELECT`!

Ответ кроется в **логическом порядке выполнения** запроса движком базы данных. Он отличается от порядка написания кода:

1.  **`FROM`**: Сначала база данных определяет, с какой таблицей она работает (`employees`).
2.  **`WHERE`**: Затем она применяет фильтр ко **всем** строкам этой таблицы. На этом этапе она проверяет условие `annual_salary > 650000`.
3.  **`SELECT`**: И только для тех строк, что прошли фильтр, база данных вычисляет выражения из `SELECT` (включая наш псевдоним `annual_salary`).

На шаге `WHERE` псевдоним `annual_salary` еще просто не существует!

> **Для админа Linux: Аналогии**
>
> Представьте себе конвейер (pipe) в Linux:
>
> `cat employees.csv | awk -F, '$4 > 650000' | awk -F, '{print $1, $2, $3 * 12}'`
>
> Вы не можете использовать результат последнего `awk` (вычисление годовой зарплаты) в первом `awk` (фильтрация). Точно так же и в SQL.

**Как это исправить? (Наивный способ)**

Вы можете просто дублировать вычисление в `WHERE`:

```sql
SELECT
    id,
    name,
    salary * 12 AS annual_salary
FROM
    employees
WHERE
    salary * 12 > 650000;
```
Этот код работает, но он нарушает принцип **DRY (Don't Repeat Yourself)**. Если формула расчета сложная, ее дублирование — прямой путь к ошибкам.

### Лучшая практика: `WITH` (Common Table Expressions)

Современный SQL предлагает элегантное решение этой проблемы — **Common Table Expressions (CTE)** или обобщенные табличные выражения. Они объявляются с помощью ключевого слова `WITH`.

CTE позволяет создать временную, "виртуальную" таблицу, на которую можно ссылаться в основном запросе.

```sql
WITH calculated_salary AS (
    SELECT
        id,
        name,
        salary,
        salary * 12 AS annual_salary
    FROM
        employees
)
SELECT *
FROM calculated_salary
WHERE annual_salary > 650000;
```
**Результат:**
```
        ID NAME                                                   SALARY ANNUAL_SALARY
---------- -------------------------------------------------- ---------- -------------
         2 Jane Smith                                              60000        720000
```
**Как это работает:**
1.  Блок `WITH` определяет временный набор данных `calculated_salary`, в котором уже вычислен наш псевдоним.
2.  Основной `SELECT` работает уже с этой "виртуальной" таблицей, где колонка `annual_salary` существует и доступна для фильтрации.

Этот подход не только решает проблему с псевдонимами, но и делает сложные запросы гораздо более читаемыми и модульными. Возьмите его на вооружение — это признак хорошего тона в SQL.

### Что дальше?

Мы разобрались с логикой выполнения запросов. В следующем уроке мы поговорим о сортировке данных и о том, как Oracle обходится с `NULL` при упорядочивании.
